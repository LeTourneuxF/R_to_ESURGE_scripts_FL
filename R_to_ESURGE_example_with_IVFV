
#Code adapted from the 'first steps.txt' file from RÃ©mi Choquet for the R to E-SURGE function
#Working directory, results from E-SURGE runs will be saved to that directory 
setwd('C:\\.....')

###################
#  with R: example 2
###################

library('R.matlab')

## Connect to each of them
matlab1 <- Matlab(port=9999); open(matlab1)

## Open a headed file with E-SURGE (important to do before trying to load the model!)
#Numbers at the end of the data loading command: (file type, nothing, nothing, noting, #states, #events)
#File type: 1- Biomeco; 2- mark; 3- headed
#Biomeco format does not prompt a window asking for covariates, so this file format should be used if you want to load multiple datasets for multiple iterations uninterrupted

evaluate(matlab1, "[his,eff,autre]=esurge_data_from_file('C:/Users/Frederic Letourneaux/Documents/Doc/Data/2019 Hiver/simul10/iter1/','CH_sim_iter1.rh',1,1,1,50,7,4)")
#evaluate(matlab1, "[his,eff,autre]=esurge_data_from_file('C:/Users/Frederic Letourneaux/Documents/Doc/Data/2019 Hiver/simul8/iter1/','CH_sim_iter1.prn',2,1,1,50,7,4)")

#Look at your data
res <- getVariable(matlab1, c("his", "eff", "autre"))
print(res$his)
print(res$eff)

##Load the model a first time from an excel file (preivously run model)
evaluate(matlab1,"[modeldef,datadef,phrasedef,ivfvdef]=esurge_model('C:/Users/Frederic Letourneaux/Documents/Doc/Data/2019 Hiver/simul10/','iter1_fallrec', autre)")
#get the model definition in R
mod<-getVariable(matlab1,'modeldef')


#Extract the number of parameters to estimate
n.pars<-length(mod[[1]][[3]][[1]]$paramath)

#Number of iterations
n.iter<-5

#Matrices and vectors to store results
result.biol    <-matrix(NA, ncol=n.iter, nrow=n.pars)
result.real    <-matrix(NA, ncol=n.iter, nrow=n.pars)
sigma          <-matrix(NA, ncol=n.iter, nrow=n.pars)
sigmaplus      <-matrix(NA, ncol=n.iter, nrow=n.pars)
sigmamoins     <-matrix(NA, ncol=n.iter, nrow=n.pars)
initial_values <-matrix(NA, ncol=n.iter, nrow=n.pars)
devi           <-rep(NA, length=n.iter)



#Loop for running model with multiple initial values
for(i in 1:n.iter){
  

  ##Load the model from excel for each iteration to make sure no information from previous runs is carried along
  evaluate(matlab1,"[modeldef,datadef,phrasedef,ivfvdef]=esurge_model('C:/Users/Frederic Letourneaux/Documents/Doc/Data/2019 Hiver/simul10/','iter1_fallrec', autre)")

  #Fix parameters
  evaluate(matlab1,"strI=phrasedef{1};strT=phrasedef{2};strC=phrasedef{3};NumSC=phrasedef{4};strSC=phrasedef{5};list_cluster=datadef{1},filenamex=phrasedef{6}")
  evaluate(matlab1,"[modeldef,sep]=esurge_gemaco(modeldef,strI,strT,strC,NumSC,strSC,list_cluster,filenamex)")

  #indices of parameter to fix (real scale); indices of parameter to fix (biol scale); values for each (rl scale); values for each (biol scale)
  evaluate(matlab1,"indR=[];indB=[9 188 189];valR=[];valB=[1 0 0];") 

  #Write fixed values to model definition
  evaluate(matlab1,"[modeldef,ivfvdef]=esurge_ivfv(modeldef,sep,indR,indB,valR,valB)")

  #Function to attribute initial values. 
  #Important that they are in the right order. Also best if stored as a vector (matrices do not work so well right now)
  #IVs need to be on the real scale!
  init.val<-IV(fulltime=F, sumrec=T)

  #Send IVs to matlab
  setVariable(matlab1,x=init.val);
  evaluate(matlab1,"model=modeldef{3};")

  #Write IVs to model definition
  evaluate(matlab1,"model.paramath=x;");

  #Display IVs to make sure all is ok in the matlab window
  evaluate(matlab1,"display(model.paramath);")


  evaluate(matlab1,"modeldef{3}=model;")


  ##############################################################################
  # Fitting a Multi-event model with
  # 	nt=1 : computation of the proportion in each state (otherwise nt=0)
  #       mecond=0 : conditionaly to the first capture
  ##############################################################################
  evaluate(matlab1,"nt=1; mecond=0;")

  #Run the model
  evaluate(matlab1,"[dev0, para0, modeldef,sigma,sigmaplus,sigmamoins]=esurge_run(his,eff,autre,modeldef,nt,mecond,'FIT RANK');")

  #If you want to calculate CI you can call the next line:
  #evaluate(matlab1,"[dev0, para0, modeldef,sigma,sigmaplus,sigmamoins]=esurge_run(his,eff,autre,modeldef,nt,mecond,'CI');")
  #This can also be put in the same command line this way: 'FIT CI RANK'


  #Extract results to R
  res <- getVariable(matlab1,c("dev0","para0",'sigma','sigmaplus', 'sigmamoins'))

  #apply the logit to para0 to get the probabilities
  result.biol[,i]<-exp(res$para0)/(exp(res$para0)+1)
  result.real[,i]<-res$para0

  devi[i]<-res$dev0

  sigma[,i]<-res$sigma
  sigmaplus[,i]<-res$sigmaplus
  sigmamoins[,i]<-res$sigmamoins

  initial_values[,i]<-init.val


}#End iteration loop

#If results to be stored in different files for each iteration, can use the script below directly in the loop
#set i to 1 if only needed once.
i=1


#Give name of file to store results in
mod_run<-"name_of_your_model"
#save results
write.table(result.biol, file=paste(mod_run,i,'_result_biol.txt', sep=''), col.names = T, row.names = T)
write.table(result.real, file=paste(mod_run,i,'_result_real.txt', sep=''), col.names = T, row.names = T)
write.table(sigma, file=paste(mod_run,i,'_sigma.txt', sep=''), col.names = T, row.names = T)
write.table(sigmaplus, file=paste(mod_run,i,'_sigmaplus.txt', sep=''), col.names = T, row.names = T)
write.table(sigmamoins, file=paste(mod_run,i,'_sigmamoin.txt', sep=''), col.names = T, row.names = T)
write.table(devi, file=paste(mod_run,i,'_deviance.txt', sep=''), col.names = T, row.names = T)





