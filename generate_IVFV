#Important: do not include the fixed parameters in your counts. Only include the parameters that will be estimated.
#If all birds are in the same state at capture (IS), then this parameter will NOT be estimated and the proportion for this state is automatically 1.
#If you have only 1 initial state, do not take it into account and there is no need to specify it.
#Right now, this function does not work if you have multiple steps of initial states.

IV<-function(init.states=NULL, # title of initial parameters
             np.inits=0,       # number of parameters
             inits.up=NULL,    # max value for IV inits
             inits.low=NULL,   # min value for IV inits
             transitions,      # title of transision parameters
             np.trs,           # number of probabilities to estimate for each transition parameter
             trs.up,           # max value for IV transition
             trs.low,          # min value for IV transition
             events,           # title of event parameters
             np.event,         # number of probabilities to estimate for each event parameter
             event.up,         # max value for IV event   
             event.low){       # min value for IV event 


  #Lower and upper bound of IVs for each parameter. Rows: parameters, column1: min value, column2: max value
  is.values<-cbind(inits.low, inits.up)
  
  #Lower and upper bound of IVs for each parameter. Rows: parameters, column1: min value, column2: max value
  trans.values<-cbind(trs.low,trs.up)

  #Lower and upper bound of IVs for each parameter. Rows: parameters, column1: min value, column2: max value
  event.values<-cbind(event.low,event.up)


  #number of parameters total
  npars<-sum(np.inits, np.trs, np.event)
  
  #Create matrix to store initial values
  IVFV<-matrix(NA, nrow=npars, ncol=3)
  
  IVFV<-as.data.frame(IVFV)
  
  colnames(IVFV)<-c("V1","V2","par")
  
  # V1:  (fix.biol(2) fix.real(1) or init(0) values
  # V2:  parameter initial value
  # par: name of parameter column)
  
  IVFV$V1<-0
  
  #Assign parameter names to lines, easier to check before using, but not necessary
  #The important part is that your parameters are ordered correctly in the matrix (same order as generated by your GEMACO definition)
  
  #First write down initial states
  if(length(init.states)>0){
    
    is.ind<-1:sum(np.inits)
    
    #A little gymnastic to obtain a vector of length equal to # of transision parameters  
    indic.is<-matrix(NA, ncol=length(np.inits), nrow=max(np.inits))
    
    for (i in 1:ncol(indic.is)){
      is.vec<-rep(NA, times=max(np.inits))
      
      is.vec[1:np.inits[i]]<-rep(i, times=np.inits[i])  
      
      indic.is[,i]<-is.vec
    }
    
    #This gives you the value to go get from the 'transitions' vector 
    indic.is<-as.vector(indic.is)
    
    #Éviter de supprimer toutes les données si aucun NA
    na.indic.is<-which(is.na(indic.is))
    
    if(length(na.indic.is)>0){
      indic.is<-indic.is[-na.indic.is]
    }
    
    #Write the right parameter for transition
    for(i in is.ind){
      
      #Write the string with parameter class 
      IVFV[i,3]<-init.states[indic.is[(i-min(is.ind)+1)]]
      
      #Write the initial value from values entered at the top of the script
      IVFV[i,2]<-runif(1,is.values[indic.is[(i-min(is.ind)+1)],1],is.values[indic.is[(i-min(is.ind)+1)],2])
      
    }
    }
  
    
  
  #Next, calculate the indices for rows of transitions and event
  #transition  
  trans.ind<-sum(np.inits,1):sum(np.trs,np.inits)
  
  #A little gymnastic to obtain a vector of length equal to # of transision parameters  
  indic.trs<-matrix(NA, ncol=length(np.trs), nrow=max(np.trs))
  
  for (i in 1:ncol(indic.trs)){
    tr.vec<-rep(NA, times=max(np.trs))
    
    tr.vec[1:np.trs[i]]<-rep(i, times=np.trs[i])  
    
    indic.trs[,i]<-tr.vec
  }
  
  #This gives you the value to go get from the 'transitions' vector 
  indic.tr<-as.vector(indic.trs)
  
  #Éviter de supprimer toutes les données si aucun NA
  na.indic.tr<-which(is.na(indic.tr))
  
  if(length(na.indic.tr)>0){
    indic.tr<-indic.tr[-na.indic.tr]
  }
  
  #Write the right parameter for transition
  for(i in trans.ind){
    
    #Write the string with parameter class 
    IVFV[i,3]<-transitions[indic.tr[(i-min(trans.ind)+1)]]
    
    #Write the initial value from values entered at the top of the script
    IVFV[i,2]<-runif(1,trans.values[indic.tr[(i-min(trans.ind)+1)],1],trans.values[indic.tr[(i-min(trans.ind)+1)],2])
    
  }
  
  
  
  #events  
  event.ind<-sum(np.inits,np.trs,1):npars
  
  #A little gymnastic to obtain a vector of length equal to # of transision parameters  
  indic.event<-matrix(NA, ncol=length(np.event), nrow=max(np.event))
  
  for (i in 1:ncol(indic.event)){
    
    event.vec<-rep(NA, times=max(np.event))
    
    event.vec[1:np.event[i]]<-rep(i, times=np.event[i])  
    
    indic.event[,i]<-event.vec
  }
  
  
  indic.ev<-as.vector(indic.event)
  
  #Éviter de supprimer toutes les données si aucun NA
  na.indic.ev<-which(is.na(indic.ev))
  
  if(length(na.indic.ev)>0){
    indic.ev<-indic.ev[-na.indic.ev]
    
  }
  
  
  #Write the right parameter for transition
  for(i in event.ind){
    
    #Write the string with parameter class 
    IVFV[i,3]<-events[indic.ev[(i-min(event.ind)+1)]]
    
    #Write the initial value from values entered at the top of the script
    IVFV[i,2]<-runif(1,event.values[indic.ev[(i-min(event.ind)+1)],1],event.values[indic.ev[(i-min(event.ind)+1)],2])
    
  }
    
       
  IV.file<-as.matrix(IVFV[,1:2])
  
  #select only lines with parameters that are not fixed (column V1==0)
  init.vals<-as.vector(IV.file[which(IV.file[,1]==0),2])
  
  #Transform on the real scale
  init.real<-log(init.vals/(1-init.vals))
  
  return(list(init.real=init.real, IVFV=IVFV))
  
}



#EX.1: Simple example with dipper data (E-SURGE tutorials)
transitions <-c('surv')
np.trs      <-c(6)
trs.up      <-c(1)     #(max val for survival)
trs.low     <-c(0.5)   #(min val for survival)

events      <-c('recap')
np.event    <-c(6)
event.up    <-c(0.9) 
event.low   <-c(0.3)


#If no initial states to estimate, no need to specify them in the function (there are default values), unlike the other 8.

init.vals<-
  IV(#init.states = init.states, 
     #np.inits    = np.inits,    
     #inits.up    = inits.up,    
     #inits.low   = inits.low,   
     transitions = transitions, 
     np.trs      = np.trs,      
     trs.up      = trs.up,      
     trs.low     = trs.low,     
     events      = events,      
     np.event    = np.event,    
     event.up   = event.up,   
     event.low  = event.low)

#Can check IVFV to be sure that all is OK (with parameter names)
init.vals$IVFV

#Get inits on the real scale
init.vals$init.real




#EX.2: More elaborated example with geese model, multiple parameters and estimates in different caterogies to understand how to structure your data
init.states <-c("AC", 'AL', "ND1L")
np.inits    <-c(1   , 1   , 1)
inits.up    <-c(0.3 , 0.9 , 0.1)
inits.low   <-c(0.1 , 0.5 , 0)

transitions <-c('col.loss', 'surv')
np.trs      <-c(1         ,  4)
trs.up      <-c(0.05      ,  0.999)  #(max val for col loss, max val for survival)
trs.low     <-c(0         ,  0.85)   #(min val for col loss, min val for survival)

events      <-c('recap','rec.band','obs.col','obs.hunt','rec.col')
np.event    <-c(21     , 40       , 39      , 39       , 40)
event.up    <-c(0.05   , 0.4      , 0.6     , 0.3      , 0.4) 
event.low   <-c(0      , 0.15     , 0.4     , 0.2      , 0.15)


#If no initial states to estimate, no need to specify them in the function (there are default values), unlike the other 8.
init.vals<-
  IV(init.states = init.states, 
     np.inits    = np.inits,    
     inits.up    = inits.up,    
     inits.low   = inits.low,   
     transitions = transitions, 
     np.trs      = np.trs,      
     trs.up      = trs.up,      
     trs.low     = trs.low,     
     events      = events,      
     np.event    = np.event,    
     event.up   = event.up,   
     event.low  = event.low)

#Can check IVFV to be sure that all is OK (with parameter names)
init.vals$IVFV

#Get inits on the real scale
init.vals$init.real






