#Important: do not include the fixed parameters in your counts
IV<-function(){

#number of initial states
init.states<-3

#transitions, in the order they are defined in E-SURGE
transitions<-c('col.loss', 'surv')

#Number of probabilities to estimate for each parameter
np.trs<-c(1,4)

#Lower and upper bound of IVs for each parameter. Rows: parameters, column1: min value, column2: max value
trans.values<- matrix(nrow=length(np.trs), ncol=2)
trans.values[1,]<-c(0     , 0.05)
trans.values[2,]<-c(0.85  , 1   )
#[...]


#event, in the order they are defined in E-SURGE
event<-c('recap','rec.band','obs.col','obs.hunt','rec.col')

#Number of probabilities to estimate for each parameter
np.event<-c(21,40,39,39,40)

#Lower and upper bound of IVs for each parameter. Rows: parameters, column1: min value, column2: max value
event.values<- matrix(nrow=length(np.event), ncol=2)
event.values[1,]<-c(0     , 0.05)
event.values[2,]<-c(0.15  , 0.4)
event.values[3,]<-c(0.4   , 0.6)
event.values[4,]<-c(0.2   , 0.3)
event.values[5,]<-c(0.15  , 0.4)
#[...]



  #number of parameters total
  npars<-sum(init.states, np.trs, np.event)
  
  #Create matrix to store initial values
  IVFV<-matrix(NA, nrow=npars, ncol=3)
  
  IVFV<-as.data.frame(IVFV)
  
  colnames(IVFV)<-c("V1","V2","par")
  
  # V1:  (fix.biol(2) fix.real(1) or init(0) values
  # V2:  parameter initial value
  # par: name of parameter column)
  
  IVFV$V1<-0
  
  #Assign parameter names to lines, easier to check before using, but not necessary
  #The important part is that your parameters are ordered correctly in the matrix (same order as generated by your GEMACO definition)
  
  #First write down initial states
    for(i in 1:init.states){
      IVFV[i,3]<-'IS'
      
      #If the proportion in each initial state is known, you could give specific IV's for each, as is done with transitions and events
      IVFV[i,2]<-0.5
    }
    
  #Next, calculate the indices for rows of transitions and event
  #transition  
  trans.ind<-(init.states+1):sum(np.trs,init.states)
  
  
  #A little gymnastic to obtain a vector of length equal to # of transision parameters  
  indic.trs<-matrix(NA, ncol=length(np.trs), nrow=max(np.trs))
 
   for (i in 1:ncol(indic.trs)){
     tr.vec<-rep(NA, times=max(np.trs))
     
     tr.vec[1:np.trs[i]]<-rep(i, times=np.trs[i])  
      
      indic.trs[,i]<-tr.vec
   }
    
    indic<-as.vector(indic.trs)
    
    #This gives you the value to go get from the 'transitions' vector 
    indic<-indic[-which(is.na(indic))]
        
 #Write the right parameter for transition
    for(i in trans.ind){
      
      #Write the string with parameter class 
      IVFV[i,3]<-transitions[indic[(i-min(trans.ind)+1)]]
      
      #Write the initial value from values entered at the top of the script
      IVFV[i,2]<-runif(1,trans.values[indic[(i-min(trans.ind)+1)],1],trans.values[indic[(i-min(trans.ind)+1)],2])
          
          }
        

    
    #events  
    event.ind<-sum(init.states,np.trs,1):npars
    
    #A little gymnastic to obtain a vector of length equal to # of transision parameters  
    indic.event<-matrix(NA, ncol=length(np.event), nrow=max(np.event))
    
    for (i in 1:ncol(indic.event)){
      
      event.vec<-rep(NA, times=max(np.event))
      
      event.vec[1:np.event[i]]<-rep(i, times=np.event[i])  
      
      indic.event[,i]<-event.vec
    }
    
    indic<-as.vector(indic.event)
    indic<-indic[-which(is.na(indic))]
    
    #Write the right parameter for transition
    for(i in event.ind){
      
      #Write the string with parameter class 
      IVFV[i,3]<-event[indic[(i-min(event.ind)+1)]]
      
      #Write the initial value from values entered at the top of the script
      IVFV[i,2]<-runif(1,event.values[indic[(i-min(event.ind)+1)],1],event.values[indic[(i-min(event.ind)+1)],2])
      
    }
    
       
  IV.file<-as.matrix(IVFV[,1:2])
  
  #select only lines with parameters that are not fixed (column V1==0)
  init.vals<-as.vector(IV.file[which(IV.file[,1]==0),2])
  
  #Transform on the real scale
  init.real<-log(init.vals/(1-init.vals))
  
  return(init.real=init.real)
  
}
